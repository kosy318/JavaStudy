<hr>
<hr>
# 객체지향 언어의 특징
OOP is A P.I.E
- 추상화(Abstraction) : 현실의 객체를 추상화해서 클래스를 구성한다.
- 상속(Inheritance) : 부모 클래스의 자산을 물려받아 자식을 정의함으로 코드의 재사용이 가능하다.
- 정보은폐(Information Hiding, EnCapsulation) : 데이터를 외부에 직접 노출시키지 않고 메서드를 아용해 보호할 수 있다.
- 다형성(Polymorphism) : 하나의 객체를 여러 가지 타입(형)으로 참조할 수 있다.

# 상속
### 상속(Inheritance)
- 기존 클래스의 자산(멤버)을 자식 클래스에서 재사용하기 위한 것<br>
부모의 생성자와 초기화 블록은 상속하지 않는다.
- 기존 클래스의 멤버를 물려 받기 때문에 코드의 절감<br>
부모의 코드를 변경하면 모든 자식들에게도 적용->유지 보수성 향상
- 상속의 적용<br>

extends 키워드 사용
- 조상 클래스 : 부모 클래스, 상위(base) 클래스, 슈퍼 클래스
- 자식 클래스 : 자손 클래스, 하위(derived) 클래스, 서브 클래스

### Object 클래스
- 모든 클래스의 조상 클래스<br>
별도의 extends 선언이 없는 클래스들은 extends Object가 생략됨<br>
따라서 모든 클래스에는 Object 클래스에 정의된 메서드가 있음

### 다양한 상속 관계
- 상속 관계는 is a 관계라고 함

### 단일 상속(Single Inheritance)
- 다중 상속의 경우 여러 클래스의 기능을 물려받을 수 있으나 관계가 매우 복잡해짐<br>
동일한 이름의 메서드가 두 부모에게 있다면 자식은 어떤 메서드를 쓸 것인가?
- 자바는 단일 상속만 지원<br>
대신 interface와 포함 관계(has a)로 단점 극복

### 포함 관계
- 상속 이외에 클래스를 재활용 하는 방법<br>
2개 이상의 클래스에서 특성을 가져올 때 하나는 상속, 나머지는 멤버 변수로 처리<br>
포함 관계의 UML 표현: 실선<br>
Spider의 코드를 수정하면 SpiderMan에도 반영되므로 유지 보수성 확보<br>

![image](https://user-images.githubusercontent.com/77595685/180128586-23826713-e242-473d-9009-8a840d595d73.png)
<br>

- 상속? 포함?<br>
- 어떤 클래스를 상속 받고 어떤 클래스를 포함해야 하는가?<br>
문법적인 문제는 아니며 프로젝트의 관점 문제<br>
상속: is a 관계가 성립하는가?<br>
포함: has a 관계가 성립하는가?<br>

# 메서드 재정의
### 메서드 오버라이딩(overriding)
- 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것
- 오버라이딩의 조건
  - 메서드 이름이 같아야한다.
  - 매개 변수의 개수, 타입, 순서가 같아야 한다.
  - 리턴 타입이 같아야 한다.
  - 접근 제한자는 부모 보다 범위가 넓거나 같아야 한다.
  - 조상보다 더 큰 예외를 던질 수 없다.

### Annotation
- 사전적 의미: 주석
- 컴파일러, JVM, 프레임워크 등이 보는 주석
- 소스 코드에 메타 데이터를 삽입하는 형태<br>
소스 코드에 붙여 놓은 라벨<br>
코드에 대한 정보 추가->소스 코드의 구조 변경, 환경 설정 정보 추가 등의 작업 진행<br>
<br>

- JDK 1.5의 기본 annotation의 예
  - @Deprecated<br>
  컴파일러에게 해당 메서드가 deprecated(없어질 수 있음) 되었다고 알려줌
  - @Override<br>
  컴파일러에게 해당 메서드는 override한 메서드 임을 알려줌<br>
  @Override가 선언된 경우 반드시 super class에 선언 되어있는 메서드여야 함
  - @SuppressWarnings<br>
  컴파일러에게 사소한 warning의 경우 신경 쓰지 말라고 알려줌
  
## Object
### Object 클래스
- 가장 최상위 클래스로 모든 클래스의 조상

### toString 메서드
- 객체를 문자열로 변경하는 메서드
- 정작 궁금한 내용은 주소값 따위가 아닌 내용임
- override를 사용하여 변경할 수 있음

### equals 메서드
- 두 객체가 같은지를 비교하는 메서드
- 두 개의 레퍼런스 변수가 같은 객체를 가리키고 있는가?
- 우리가 비교할 것은 정말 객체의 주소 값인가?
  - 두 객체의 내용을 비교할 수 있도록 equals 메서드 재정의
  - 객체의 주소 비교: == 활용
  - 객체의 내용 비교: equals 활용

### hashCode
- 객체의 해시 코드: 시스템에서 객체를 구별하기 위해 사용되는 정수 값
- HashSet, HashMap 등에서 객체의 동일성을 확인하기 위해 사용
- equals 메서드를 재정의할 때는 반드시 hashCode도 재정의할 것
  - 미리 작성된 String이나 Number 등에서 재정의된 hashCode 활용 권장

## super
### super 키워드
- super를 통해 조상 클래스 멤버 접근
  - super.을 이용해 조상의 메서드 호출로 조상의 코드 재사용
- 변수의 scope
  - 사용된 위치에서 점점 확장해가며 처음 만난 선언부에 연결됨
  - method 내부 -> 해당 클래스 멤버 변수 -> 조상 클래스 멤버 변수
- this()가 해당 클래스의 다른 생성자를 호출하듯 super()는 조상 클래스의 생성자 호출
  - 조상 클래스에 선언된 멤버들은 조상 클래스의 생성자에서 초기화가 이루어지므로 이를 재활용
  - 자식 클래스에 선언된 멤버들만 자식 클래스 생성자에서 초기화
- super()는 자식 클래스 생성자의 맨 첫 줄에서만 호출 가능
  - 즉 생성자의 첫 줄에만 this() 또는 super()가 올 수 있다.
- 명시적으로 this() 또는 super()를 호출하지 않은 경우 컴파일러가 super() 삽입
  - 결론적으로 맨 상위의 Object까지 객체가 다 만들어지는 구조<br>
  <br>
static method 안에서는 this, super를 사용할 수 없음.
<br>
한 파일 내에서 public은 한 클래스에만 붙일 수 있고, 그 클래스는 파일 이름이 되어야 한다.

# package & import
### package
- PC의 많은 파일 관리 -> 폴더 이용
  - 유사한 목적의 파일을 기준으로 작성
  - 이름은 의미있는 이름으로, 계층적 접근
- 프로그램의 많은 클래스 -> 패키지 이용
  - 패키지의 이름은 의미 있는 이름으로 만ㄷ르고 .를 통해 계층적 접근
  - 물리적으로 패키지는 클래스 파일을 담고 있는 디렉터리
- package의 선언
  - package pakage_name;
  - 주석, 공백을 제외한 첫 번째 문장에 하나의 패키지만 선언
  - 모든 클래스는 반드시 하나의 패키지에 속한다.<br>
  <br>
  
- 일반적인 package naming 룰
  - 소속(com.어쩌고).프로젝트.용도
  
### import
- 다른 패키지에 선언된 클래스를 사용하기 위한 키워드
  - 패키지와 클래스 선언 사이에 위치
  - 패키지와 달리 여러 번 선언 가능
- 선언 방법
  - import 패키지명.클래스명;
  - import 패키지명.*;
    - 하위 패키지까지 import 하지는 않는다.
- import한 package의 클래스 이름이 동일하여 명확히 구분해야 할 때 클래스 이름 앞에 전체 패키지 명을 입력
- default import package : java.lang.*;

### 일반적인 클래스 레이아웃
1. 패키지 선언부
2. 외부 패키지 import
3. class 선언부
4. 멤버 변수
5. 초기화 블록
6. 생성자
7. 멤버 메서드

# 접근제한자와 데이터 은닉과 보호
### 제한자(modifier)
- 클래스, 변수, 메서드 선언부에 함께 사용되어 부가적인 의미 부여
- 종류
  - 접근 제한자: public, protected, (default = package), private
  - 그 외 제한자
    - static: 클래스 레벨의 요소 설정
    - final: 요소를 더 이상 수정할 수 없게 함
    - abstract: 추상 메서드 및 추상 클래스 작성
    - synchronized: 멀티스레드에서의 동기화 처리
    - ...
- 하나의 대상에 여러 제한자를 조합 가능하나 접근 제한자는 하나만 사용 가능
- 순서는 무관하나 일반적으로 접근 제한자를 맨 앞으로

### final
- 마지막, 더 이상 바뀔 수 없음
- 용도
  - final class - 더 이상 확장 할 수 없음 : 상속 금지 -> 오버라이드 방지, ex) String, Math, ...
  - final method - 더 이상 재정의 할 수 없음 : overriding 금지
  - final variable - 더 이상 값을 바꿀 수 없음 : 상수화
  
### 접근 제한자(Access modifier)
- 멤버 등에 사용되며 해당 요소를 외부에서 사용할 수 있는지 설정
- public : 어디서든 접근 가능
- protected : 같은 클래스, 같은 패키지, 다른 패키지의 자손 클래스까지 접근 가능
- package(default) : 같은 클래스, 같은 패키지에서 접근 가능
- private : 같은 클래스에서만 접근 가능<br>
<br>

- method override 조건의 확인<br>
부모의 제한자 범위와 같거나 넓은 범위로만 사용 가능<br>

### 데이터 은닉과 보호(Encapsulation)
- 누군가 당신의 정보를 마음대로 바꾼다면?
- 소중한 정보가 보호되지 못하는 이유는?
  - 외부에서 변수에 직접 접근하기 때문
- 정보를 보호하기 위한 대책은?
  - 변수는 private 접근으로 막기
  - 공개되는 메서드를 통한 접근 통로 마련: setter/ getter
    - 메서드에 정보 보호 로직 작성
    
### 객체의 생성 제어와 Singleton 디자인 패턴
- 객체의 생성을 제한해야 한다면?
  - 여러 개의 객체가 필요 없는 경우
    - 객체를 구별할 필요가 없는 경우 = 수정 가능한 멤버 변수가 없고 기능만 있는 경우
    - 이런 객체를 stateless한 객체라고 한다. 상태를 가지지 않고 기능만 가지는 클래스!!!
  - 객체를 계속 생성/삭제 하는데 많은 비용이 들어서 재사용이 유리한 경우<br>
<br>

- Singleton 디자인 패턴
  - 외부에서 생성자에 접근 금지 -> 생성자의 접근 제한자를 private으로 설정
  - 내부에서는 private에 접근 가능하므로 직접 객체 생성 -> 멤버 변수이므로 private 설정
  - 외부에서 private member에 접근 가능한 getter 생성 -> setter는 불필요
  - 객체 없이 외부에서 접근할 수있도록 getter와 변수에 static 추가<br>
  <br>
  
  - 외부에서는 언제나 getter를 통해서 객체를 참조하므로 하나의 객체 재사용
  
# 다형성
### 다형성(Polymorphism)
- 하나의 객체가 많은 형(타입)을 가질 수 있는 성질
- 정의 : 상속관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 레퍼런스 할 수 있다.

### 다형성의 활용 예1 - 다른 타입의 객체를 다루는 배열
- 배열의 특징 : 같은 타입의 데이터를 묶음으로 다룬다.
- 다형성으로 다른 타입의 데이터(Person, SpiderMan)를 하나의 배열로 관리
- Object는 모든 클래스의 조상으로 Object의 배열은 어떤 타입의 객체라도 다 저장할 수 있음
- 자바의 자료 구조를 간단하게 처리할 수 있음

### 다형성의 활용 예2 - 매개변수의 다형성
- 메소드가 호출되기 위해선 메소드 이름과 파라미터가 맞아야하는데... 조상을 파라미터로 처리한다면 객체의 타입에 따라 메소드를 따로 만들 필요가 없음
- API에서 파라미터로 Object를 받는다는 것은 모든 객체를 처리한다는 말이다.
- 필요하다면 하위 클래스에서 오버라이딩 필요

## 다형성 활용
### 다형성과 참조형 객체의 형 변환
- 메모리에 있는 것과 사용할 수 있는 것의 차이
  - 메모리에 있더라도 참조하는 변수의 타입에 따라 접근할 수 있는 내용이 제한됨

### 참조형 객체의 형 변환
- 작은 집(child)에서 큰 집(super)으로 -> 묵시적 캐스팅
  - 자손 타입의 객체를 조상 타입으로 참조: 형변환 생략 가능
```java
Phone phone = new Phone();
Object obj = phone;
```
- 큰집(super)에서 작은 집(child)으로 -> 명시적 캐스팅
  - 조상 타입을 자손 타입으로 참조: 형변환 생략 불가
```java
Phone phone = new SmartPhone();
SmartPhone sPhone = (SmartPhone)phone;
```
- 조상을 무조건 자손으로 바꿀 수는 없다
  - instanceof 연산자로 확인 후 형변환!
    - 실제 메모리에 있는 객체가 특정 클래스 타입인지 boolean으로 리턴
  ```java
  Person person = new Person();
  
  if(person instanceof SpiderMan){
    SpiderMan sman = (SpiderMan)person;
  }
  ```

### 참조 변수의 레벨에 따른 객체의 멤버 연결
- 상속 관계에서 객체의 멤버 변수가 중복될 때
  - 참조 변수의 타입에 따라 연결이 달라짐
- 상속 관계에서 객체의 메서드가 중복될 때(메서드가 override 되었을 때)
  - 무조건 자식 클래스의 메서드가 호출됨 -> virtual method inovation
  - 최대한 메모리에 생성된 실제 객체에 최적화 된 메서드가 동작한다.
- 상위로 올라갈 수록 활용도도 높아짐, 하지만 코드의 복잡성도 함께 증가
- Java API처럼 공통 기능인 경우 Object를 파라미터로 쓰겠지만 많은 경우 비즈니스 로직 상 최상위 객체 사용 권장
